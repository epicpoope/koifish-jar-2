{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\nbrain = Brain()\n\ncontroller_1 = Controller(PRIMARY)\nsolenoid = DigitalOut(brain.three_wire_port.h)\n\nwait(30, MSEC)\n\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\ninitializeRandomSeed()\n\nwait(200, MSEC)\nprint(\"\\033[2J\")\n#endregion\n\n# ================== Devices ==================\ncontroller = Controller()\n\n# Drive motors\nleft_front = Motor(Ports.PORT1, GearSetting.RATIO_6_1, True)\nleft_middle = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nleft_back = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\n\nright_front = Motor(Ports.PORT9, GearSetting.RATIO_6_1, False)\nright_middle = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nright_back = Motor(Ports.PORT20, GearSetting.RATIO_6_1, False)\n\n# Intake motors (fixed directions)\nintake1 = Motor(Ports.PORT7, GearSetting.RATIO_6_1, False)   # reversed\nintake2 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)  # not reversed\n\n# Inertial sensor\ninertial_sensor = Inertial(Ports.PORT16)\n\n# Stopping modes\nfor motor in [left_front, left_middle, left_back, right_front, right_middle, right_back, intake1, intake2]:\n    motor.set_stopping(COAST)\n\n# ================== PID Class ==================\nclass PID:\n    def __init__(self, kP=0.0, kI=0.0, kD=0.0, integral_limit=50):\n        self.kP = kP\n        self.kI = kI\n        self.kD = kD\n        self.integral_limit = integral_limit\n\n        self.error = 0\n        self.prev_error = 0\n        self.integral = 0\n        self.derivative = 0\n\n    def reset(self):\n        self.error = 0\n        self.prev_error = 0\n        self.integral = 0\n        self.derivative = 0\n\n    def calculate(self, target, current):\n        self.error = target - current\n        self.integral += self.error\n        if abs(self.integral) > self.integral_limit:\n            self.integral = self.integral_limit * (1 if self.integral > 0 else -1)\n        self.derivative = self.error - self.prev_error\n        self.prev_error = self.error\n        return (self.kP * self.error) + (self.kI * self.integral) + (self.kD * self.derivative)\n\n# ================== Drive Helpers ==================\nWHEEL_DIAMETER_IN = 3.25\nWHEEL_CIRCUMFERENCE = WHEEL_DIAMETER_IN * math.pi\nGEAR_RATIO = 0.75\n\ndef inches_to_degrees(inches):\n    wheel_rotations = inches / WHEEL_CIRCUMFERENCE\n    motor_rotations = wheel_rotations / GEAR_RATIO\n    return motor_rotations * 360\n\ndef reset_drive_encoders():\n    for motor in [left_front, left_middle, left_back, right_front, right_middle, right_back]:\n        motor.set_position(0, DEGREES)\n\n# ================== PID Driving ==================\ndef drive_pid(target_inches, timeout=3000, max_power=35, deadband=1.5):\n    target_degrees = inches_to_degrees(target_inches)\n    pid = PID(kP=0.25, kI=0.0, kD=0.1)\n    pid.reset()\n    reset_drive_encoders()\n    start_time = brain.timer.time(MSEC)\n\n    while brain.timer.time(MSEC) - start_time < timeout:\n        current = (left_front.position(DEGREES) + right_front.position(DEGREES)) / 2\n        power = pid.calculate(target_degrees, current)\n        if abs(target_degrees - current) < inches_to_degrees(deadband):\n            break\n        if power > max_power:\n            power = max_power\n        if power < -max_power:\n            power = -max_power\n        for motor in [left_front, left_middle, left_back]:\n            motor.spin(FORWARD, power, PERCENT)\n        for motor in [right_front, right_middle, right_back]:\n            motor.spin(FORWARD, power, PERCENT)\n        wait(20, MSEC)\n    for motor in [left_front, left_middle, left_back, right_front, right_middle, right_back]:\n        motor.stop()\n\ndef turn_pid(target_angle, timeout=2000, max_power=35):\n    pid = PID(kP=0.45, kI=0.0, kD=0.2)\n    pid.reset()\n    start_time = brain.timer.time(MSEC)\n\n    while brain.timer.time(MSEC) - start_time < timeout:\n        current_angle = inertial_sensor.rotation(DEGREES)\n        power = pid.calculate(target_angle, current_angle)\n        if power > max_power:\n            power = max_power\n        if power < -max_power:\n            power = -max_power\n        for motor in [left_front, left_middle, left_back]:\n            motor.spin(FORWARD, power, PERCENT)\n        for motor in [right_front, right_middle, right_back]:\n            motor.spin(REVERSE, power, PERCENT)\n        wait(20, MSEC)\n    for motor in [left_front, left_middle, left_back, right_front, right_middle, right_back]:\n        motor.stop()\n\n# ================== States ==================\nis_tank_drive = False\ndrive_speed = 100\npneumatics_extended = False\n\nprev_toggle_combo = False\nprev_speed_toggle = False\nprev_pneumatics_press = False\n\ndef apply_deadzone(value, threshold=5):\n    return 0 if abs(value) < threshold else value\n\n# ================== Pre-Autonomous ==================\ndef pre_auton():\n    brain.screen.clear_screen()\n    brain.screen.print(\"Calibrating inertial...\")\n    inertial_sensor.calibrate()\n    while inertial_sensor.is_calibrating():\n        wait(100, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.print(\"Ready!\")\n\n# ================== Intake Functions ==================\ndef intake_forward(power=100):\n    intake1.spin(FORWARD, power, PERCENT)\n    intake2.spin(FORWARD, power, PERCENT)\n    intake2.set_stopping(COAST)\n\ndef intake1_forward_only(power=100):\n    intake1.spin(FORWARD, power, PERCENT)\n    intake2.stop()\n    intake2.set_stopping(HOLD)\n\ndef intake_reverse(power=100):\n    intake1.spin(REVERSE, power, PERCENT)\n    intake2.spin(REVERSE, power, PERCENT)\n    intake2.set_stopping(COAST)\n\ndef intake_stop():\n    intake1.stop()\n    intake2.stop()\n    intake2.set_stopping(COAST)\n\n# ================== Autonomous ==================\ndef autonomous():\n    intake1_forward_only()\n    drive_pid(38)  \n    wait(1,SECONDS)\n    intake_stop()\n        # stop intake intake_stop(). intake_forward()\n    drive_pid(-20)\n    turn_pid(90)\n    drive_pid(20)\n    turn_pid(180)\n    drive_pid(-18)\n    intake_forward()\n    wait(3,SECONDS)\n    intake_stop()\n\n# ================== Driver Control ==================\ndef driver_control():\n    global is_tank_drive, drive_speed\n    global prev_toggle_combo, prev_speed_toggle, prev_pneumatics_press, pneumatics_extended\n\n    while True:\n        # === Intake Control ===\n        if controller.buttonR1.pressing():\n            intake_forward()\n        elif controller.buttonR2.pressing():\n            intake1_forward_only()\n        elif controller.buttonL1.pressing():\n            intake_reverse()\n        else:\n            intake_stop()\n\n        # === Drive Mode Toggle (Y + Right) ===\n        toggle_combo = controller.buttonY.pressing() and controller.buttonRight.pressing()\n        if toggle_combo and not prev_toggle_combo:\n            is_tank_drive = not is_tank_drive\n            brain.screen.clear_screen()\n            brain.screen.print(\"Drive Mode: \" + (\"Tank\" if is_tank_drive else \"Arcade\"))\n        prev_toggle_combo = toggle_combo\n\n        # === Speed Toggle (B) ===\n        curr_speed_toggle = controller.buttonB.pressing()\n        if curr_speed_toggle and not prev_speed_toggle:\n            drive_speed = 50 if drive_speed == 100 else 100\n            brain.screen.clear_screen()\n            brain.screen.print(\"Speed: \" + str(drive_speed) + \"%\")\n        prev_speed_toggle = curr_speed_toggle\n\n        # === Drive Control ===\n        if is_tank_drive:\n            left_speed = apply_deadzone(controller.axis3.position()) * drive_speed / 100\n            right_speed = apply_deadzone(controller.axis2.position()) * drive_speed / 100\n        else:\n            fwd = apply_deadzone(controller.axis3.position())\n            turn = apply_deadzone(controller.axis1.position())\n            left_speed = (fwd + turn) * drive_speed / 100\n            right_speed = (fwd - turn) * drive_speed / 100\n\n        for motor in [left_front, left_middle, left_back]:\n            motor.spin(FORWARD, left_speed, PERCENT)\n        for motor in [right_front, right_middle, right_back]:\n            motor.spin(FORWARD, right_speed, PERCENT)\n\n        # === Pneumatics toggle (L2) ===\n        if controller.buttonL2.pressing() and not prev_pneumatics_press:\n            solenoid.set(not pneumatics_extended)\n            pneumatics_extended = not pneumatics_extended\n        prev_pneumatics_press = controller.buttonL2.pressing()\n\n        wait(20, MSEC)\n\n# ================== Competition Object ==================\npre_auton()  # run pre-auton first\ncomp = Competition(driver_control, autonomous)\n","textLanguage":"python","robotConfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[8],"name":"solenoid","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}